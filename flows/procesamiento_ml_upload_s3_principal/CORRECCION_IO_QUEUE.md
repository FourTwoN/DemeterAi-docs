# üö® CORRECCI√ìN CR√çTICA: IO_QUEUE Orfanado - S3 Uploads No Usando Celery

**Fecha**: 2025-10-24
**Prioridad**: üî¥ CR√çTICA
**Impacto**: Arquitectura vs Implementaci√≥n no alineadas

---

## üìã Resumen Ejecutivo

Se descubri√≥ una **discrepancia CR√çTICA** entre lo que la arquitectura planea y lo que est√° implementado:

### ‚ùå Lo que DEBER√çA pasar
```
S3 uploads (original, thumbnail, visualization)
  ‚Üí Despachan tareas Celery
    ‚Üí Routan a io_queue
      ‚Üí Workers gevent (50 concurrent)
        ‚Üí Ejecutan en paralelo
```

### ‚úÖ Lo que REALMENTE pasa
```
Original upload ‚Üí Service sync (asyncio.to_thread) ‚úì
Thumbnail upload ‚Üí Service sync (asyncio.to_thread) ‚úì
Visualization uploads ‚Üí ml_aggregation_callback DIRECT boto3 (BLOQUEA) ‚úó
```

---

## üîç Lo Que Encontramos

### El io_queue EST√Å declarado pero NO se usa

**Ubicaci√≥n**: `app/celery_app.py`

#### ‚úÖ CONFIGURADO (L√≠neas 110-121)
```python
app.conf.task_queues = (
    Queue("default", Exchange("default"), routing_key="default"),
    Queue("gpu_queue", Exchange("gpu", type="direct"), routing_key="gpu"),
    Queue("cpu_queue", Exchange("cpu", type="direct"), routing_key="cpu"),
    Queue("io_queue", Exchange("io", type="direct"), routing_key="io"),  # ‚Üê AQU√ç
)
```

#### ‚úÖ WORKER CONFIGURADO (L√≠neas 188-194)
```bash
# Worker con gevent pool para 50 tareas concurrentes
celery -A app.celery_app worker \
  --pool=gevent \
  --concurrency=50 \
  --queues=io_queue \
  --hostname=io@%h
```

#### ‚úÖ ROUTING PATTERN DEFINIDO (L√≠nea 69-78)
```python
task_routes={
    "app.tasks.upload_*": {"queue": "io_queue"},  # ‚Üê Pattern para tasks upload_*
}
```

#### ‚ùå PERO NO HAY TASKS QUE USEN ESTE PATR√ìN

**En `/app/tasks/ml_tasks.py` NO existen:**
- ‚ùå `upload_original_s3_task()`
- ‚ùå `upload_thumbnail_s3_task()`
- ‚ùå `upload_visualization_s3_task()`
- ‚ùå Ninguna tarea matching `app.tasks.upload_*`

---

## üî¥ D√ìNDE SUCEDEN LOS S3 UPLOADS ACTUALMENTE

### 1. UPLOAD ORIGINAL (API Layer)
**Archivo**: `app/services/photo/photo_upload_service.py:247-278`
**Tipo**: Service call (async)
**Implementaci√≥n**:
```python
async def upload_photo(self, file: UploadFile, user_id: int):
    # ...
    original_image = await self.s3_service.upload_original(
        file_bytes=file_bytes,
        session_id=session.session_id,
    )
```

**C√≥mo funciona**:
```python
# app/services/photo/s3_image_service.py:106
async def upload_original(self, ...):
    await asyncio.to_thread(
        self.s3_client.put_object,  # boto3 sync call wrapped
        Bucket=bucket,
        Key=s3_key,
        Body=file_bytes,
    )
```

**Problema**: Se ejecuta en el thread de FastAPI durante el request
**Soluci√≥n**: Deber√≠a usar `upload_original_s3_task.delay()`

---

### 2. UPLOAD THUMBNAIL (API Layer)
**Archivo**: `app/services/photo/photo_upload_service.py:280-312`
**Tipo**: Service call (async)
**Implementaci√≥n**:
```python
thumbnail_bytes = generate_thumbnail(file_bytes, size=300)
thumbnail_image = await self.s3_service.upload_thumbnail(
    file_bytes=thumbnail_bytes,
    session_id=session.session_id,
)
```

**Problema**: Se ejecuta en el thread de FastAPI durante el request
**Soluci√≥n**: Deber√≠a usar `upload_thumbnail_s3_task.delay()`

---

### 3. UPLOAD VISUALIZATION (Callback Layer) üö® M√ÅS CR√çTICO
**Archivo**: `app/tasks/ml_tasks.py:797-887` (en `ml_aggregation_callback()`)
**Tipo**: Direct boto3 calls (SYNC, BLOCKING)

**Implementaci√≥n**:
```python
@app.task(queue="cpu_queue")
def ml_aggregation_callback(results, session_id):
    # ... aggregation logic ...

    # üî¥ UPLOAD VISUALIZATION (DIRECT BOTO3 - BLOQUEA)
    s3_client = boto3.client("s3")
    s3_client.put_object(  # ‚Üê SYNC, no await, no Celery
        Bucket=settings.S3_BUCKET_ORIGINAL,
        Key=viz_s3_key,
        Body=viz_bytes,
        ContentType="image/avif",
    )

    # üî¥ UPLOAD THUMBNAIL ORIGINAL (DIRECT BOTO3)
    s3_client.put_object(
        Bucket=settings.S3_BUCKET_ORIGINAL,
        Key=thumbnail_original_s3_key,
        Body=thumbnail_original_bytes,
    )

    # üî¥ UPLOAD THUMBNAIL PROCESSED (DIRECT BOTO3)
    s3_client.put_object(
        Bucket=settings.S3_BUCKET_ORIGINAL,
        Key=thumbnail_processed_s3_key,
        Body=thumbnail_processed_bytes,
    )

    # üî¥ COMMIT DATABASE
    db_session.commit()
```

**Problemas**:
1. ‚ùå **BLOQUEA el callback** - Las 3 uploads son s√≠ncronas
2. ‚ùå **NO usa Celery** - Deber√≠a usar `io_queue`
3. ‚ùå **Sin error handling** - Si S3 falla, toda la sesi√≥n falla
4. ‚ùå **Sin circuit breaker** - A diferencia de S3ImageService
5. ‚ùå **Ralentiza el pipeline** - La callback se bloquea esperando S3

**Tiempo estimado**:
- Generaci√≥n visualization: 1-5 segundos
- Upload visualization (3-20MB): 5-30 segundos
- Upload thumbnails (2x 1-5MB): 10-30 segundos
- **Total**: 16-65 segundos **BLOQUEANDO el callback**

---

## üìä Tabla Comparativa: Upload Locations

| # | Image | Ubicaci√≥n | Implementaci√≥n Actual | Cola Celery | Sync/Async | ¬øPROBLEMA? |
|---|-------|-----------|----------------------|-------------|-----------|-----------|
| 1 | Original | photo_upload_service.py | S3ImageService (async) | ‚ùå Ninguna | Async (to_thread) | ‚ö†Ô∏è No usa io_queue |
| 2 | Thumbnail | photo_upload_service.py | S3ImageService (async) | ‚ùå Ninguna | Async (to_thread) | ‚ö†Ô∏è No usa io_queue |
| 3 | **Visualization** | **ml_tasks.py callback** | **Direct boto3** | **‚ùå Ninguna** | **Sync (BLOQUEA)** | üî¥ **CR√çTICA** |
| 4 | **Original Thumb (ML)** | **ml_tasks.py callback** | **Direct boto3** | **‚ùå Ninguna** | **Sync (BLOQUEA)** | üî¥ **CR√çTICA** |
| 5 | **Processed Thumb** | **ml_tasks.py callback** | **Direct boto3** | **‚ùå Ninguna** | **Sync (BLOQUEA)** | üî¥ **CR√çTICA** |

---

## üöÄ SOLUCI√ìN: Crear Tasks de Upload para io_queue

### TAREA 1: Crear `upload_s3_task` Base

**Archivo a crear**: `app/tasks/s3_upload_tasks.py`

```python
from app.celery_app import app
from app.services.photo.s3_image_service import S3ImageService

@app.task(bind=True, queue="io_queue", max_retries=3)
def upload_original_s3_task(self, file_bytes: bytes, session_id: int, filename: str):
    """
    Upload original image to S3 using io_queue (gevent worker).

    Args:
        file_bytes: Image binary data
        session_id: PhotoProcessingSession ID
        filename: S3 key/filename

    Returns:
        dict with S3 upload result
    """
    try:
        s3_service = S3ImageService()

        # Upload to S3
        result = s3_service.upload_original(
            file_bytes=file_bytes,
            session_id=session_id,
            filename=filename,
        )

        return {
            "status": "success",
            "session_id": session_id,
            "filename": filename,
            "result": result,
        }

    except Exception as exc:
        # Retry with exponential backoff
        countdown = 2 ** self.request.retries  # 2s, 4s, 8s
        raise self.retry(exc=exc, countdown=countdown)


@app.task(bind=True, queue="io_queue", max_retries=3)
def upload_thumbnail_s3_task(self, file_bytes: bytes, session_id: int, filename: str):
    """Upload thumbnail to S3 using io_queue."""
    try:
        s3_service = S3ImageService()

        result = s3_service.upload_thumbnail(
            file_bytes=file_bytes,
            session_id=session_id,
            filename=filename,
        )

        return {
            "status": "success",
            "session_id": session_id,
            "filename": filename,
            "result": result,
        }

    except Exception as exc:
        countdown = 2 ** self.request.retries
        raise self.retry(exc=exc, countdown=countdown)


@app.task(bind=True, queue="io_queue", max_retries=3)
def upload_visualization_s3_task(self, file_bytes: bytes, session_id: int):
    """
    Upload visualization image to S3 using io_queue.

    This is the CRITICAL task that was blocking the callback.
    """
    try:
        s3_service = S3ImageService()

        s3_key = f"uploads/{session_id}/processed.avif"

        result = s3_service.upload_visualization(
            file_bytes=file_bytes,
            s3_key=s3_key,
            content_type="image/avif",
        )

        return {
            "status": "success",
            "session_id": session_id,
            "s3_key": s3_key,
            "result": result,
        }

    except Exception as exc:
        countdown = 2 ** self.request.retries
        raise self.retry(exc=exc, countdown=countdown)
```

---

### TAREA 2: Refactorizar `ml_aggregation_callback()` para usar tasks

**Archivo**: `app/tasks/ml_tasks.py`

#### ANTES (BLOQUEA):
```python
@app.task(queue="cpu_queue")
def ml_aggregation_callback(results, session_id):
    # ... aggregation ...

    # üî¥ DIRECT S3 UPLOAD - BLOQUEA
    s3_client = boto3.client("s3")
    s3_client.put_object(
        Bucket=settings.S3_BUCKET_ORIGINAL,
        Key=viz_s3_key,
        Body=viz_bytes,
        ContentType="image/avif",
    )

    # üî¥ MORE DIRECT UPLOADS...
```

#### DESPU√âS (AS√çNCRONO):
```python
from app.tasks.s3_upload_tasks import (
    upload_visualization_s3_task,
    upload_thumbnail_s3_task,
)

@app.task(queue="cpu_queue")
def ml_aggregation_callback(results, session_id):
    # ... aggregation ...

    # ‚úÖ DISPATCH VISUALIZATION UPLOAD (no bloquea)
    upload_task = upload_visualization_s3_task.delay(
        file_bytes=viz_bytes,
        session_id=session_id,
    )

    # ‚úÖ DISPATCH THUMBNAIL UPLOADS (no bloquea)
    upload_thumbnail_s3_task.delay(
        file_bytes=thumbnail_original_bytes,
        session_id=session_id,
        filename="thumbnail_original.jpg",
    )

    upload_thumbnail_s3_task.delay(
        file_bytes=thumbnail_processed_bytes,
        session_id=session_id,
        filename="thumbnail_processed.jpg",
    )

    # ‚úÖ UPDATE SESSION (sin esperar S3)
    _mark_session_completed(session_id, ...)

    return {
        "status": "success",
        "session_id": session_id,
        "upload_tasks": {
            "visualization": str(upload_task.id),
            "thumbnails": "2 tasks dispatched",
        }
    }
```

---

### TAREA 3: Refactorizar `PhotoUploadService` para usar tasks (OPCIONAL)

**Archivo**: `app/services/photo/photo_upload_service.py`

#### OPCI√ìN A: Mantener como est√° (service sync)
```python
# ‚úì Actual: Direct async boto3 en FastAPI request
await self.s3_service.upload_original(file_bytes, session_id)
```

**Ventaja**: R√°pido, simple
**Desventaja**: No aprovecha io_queue

#### OPCI√ìN B: Usar tasks de Celery
```python
from app.tasks.s3_upload_tasks import upload_original_s3_task

# Dispatch async task
upload_original_s3_task.delay(
    file_bytes=file_bytes,
    session_id=session_id,
    filename=f"{session_id}/original.jpg",
)

# Return 202 ACCEPTED sin esperar upload
return PhotoUploadResponse(
    task_id=upload_task.id,
    session_id=session_id,
    status="pending",
)
```

**Ventaja**: Libera FastAPI thread, usa io_queue
**Desventaja**: Upload ocurre en background

**Recomendaci√≥n**: MANTENER OPCI√ìN A (actual) - ya es async

---

## üìä Impacto de la Soluci√≥n

### ANTES (Estado Actual)
```
ML Pipeline Execution Time:
‚îú‚îÄ Segmentation: 2-3s
‚îú‚îÄ SAHI Detection: 3-5s
‚îú‚îÄ Band Estimation: 2-3s
‚îú‚îÄ Aggregation: 1-2s
‚îî‚îÄ S3 Uploads (BLOQUEADO): 16-65s  üî¥ CR√çTICO
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
TOTAL: 24-78 segundos
```

### DESPU√âS (Con Upload Tasks)
```
ML Pipeline Execution Time:
‚îú‚îÄ Segmentation: 2-3s
‚îú‚îÄ SAHI Detection: 3-5s
‚îú‚îÄ Band Estimation: 2-3s
‚îú‚îÄ Aggregation: 1-2s
‚îî‚îÄ S3 Uploads (ASYNC): 0s (dispatched)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
TOTAL: 8-13 segundos

S3 Uploads (io_queue, background): 16-65s (paralelo)
```

**Mejora**: 3-8x m√°s r√°pido para completar ML pipeline

---

## üéØ Plan de Implementaci√≥n

### PASO 1: Crear archivo `s3_upload_tasks.py` (1-2 horas)
```bash
touch app/tasks/s3_upload_tasks.py
# Implementar 3 tasks (upload_original, upload_thumbnail, upload_visualization)
```

### PASO 2: Refactorizar `ml_aggregation_callback()` (1-2 horas)
```bash
# En app/tasks/ml_tasks.py
# Cambiar direct boto3 por task.delay() calls
```

### PASO 3: Actualizar tests (1-2 horas)
```bash
# tests/unit/tasks/test_s3_upload_tasks.py
# tests/integration/test_ml_pipeline_with_uploads.py
```

### PASO 4: Verificar io_queue (30 min)
```bash
# Startup io_queue worker
celery -A app.celery_app worker --pool=gevent --queues=io_queue --concurrency=50

# Verify tasks route correctly
```

**Total estimado**: 3-6 horas

---

## üìù Checklist

- [ ] Crear `app/tasks/s3_upload_tasks.py`
- [ ] Implementar `upload_original_s3_task()`
- [ ] Implementar `upload_thumbnail_s3_task()`
- [ ] Implementar `upload_visualization_s3_task()`
- [ ] Refactorizar `ml_aggregation_callback()` para usar tasks
- [ ] Remover imports de boto3 directo de `ml_tasks.py`
- [ ] Crear tests para las nuevas tasks
- [ ] Crear test de integraci√≥n (ml_pipeline ‚Üí io_queue uploads)
- [ ] Documentar en FLUJO_PRINCIPAL_DOCUMENTACION.md
- [ ] Startup io_queue worker
- [ ] Verificar que tasks routan a io_queue
- [ ] Load test con m√∫ltiples im√°genes simult√°neas
- [ ] Verify gevent pool maneja 50 concurrent uploads

---

## üö® Discrepancia Detectada

### Arquitectura Planificada (celery_app.py):
```
io_queue configured with:
  - Exchange: "io" (direct type)
  - Routing key: "io"
  - Task pattern: "app.tasks.upload_*"
  - Worker: gevent, concurrency=50
```

### Implementaci√≥n Real (ml_tasks.py):
```
‚ùå NO hay tasks matching "app.tasks.upload_*"
‚ùå S3 uploads happen with direct boto3 in callback
‚ùå io_queue never receives any tasks
‚ùå Gevent workers never start with actual work
```

### Resultado:
- ‚úÖ Infrastructure configured (not wasted)
- ‚ùå Not utilized (orphaned)
- üî¥ Callback blocks on S3 (performance issue)
- üî¥ No error handling (reliability issue)

---

## üìö Referencias

- **Queue Configuration**: `app/celery_app.py:110-121`
- **Worker Configuration**: `app/celery_app.py:188-194`
- **Task Routing Pattern**: `app/celery_app.py:69-78`
- **Callback S3 Uploads**: `app/tasks/ml_tasks.py:797-887`
- **S3 Service**: `app/services/photo/s3_image_service.py`
- **Test Coverage**: `tests/unit/celery/test_worker_topology.py`

---

## ‚úÖ Conclusi√≥n

El `io_queue` est√° **completamente preparado pero sin tareas que lo usen**. Esta es una **correcci√≥n CR√çTICA** porque:

1. **Performance**: Callback se bloquea 16-65s esperando S3
2. **Reliability**: Sin circuit breaker, error handling
3. **Scalability**: No aprovecha gevent workers (50 concurrent)
4. **Architecture**: Desv√≠o entre plan e implementaci√≥n

**Prioridad**: üî¥ **CR√çTICA** para pr√≥ximo sprint

Estimar 3-6 horas para implementar las upload tasks y refactorizar callback.

---

**Documento creado**: 2025-10-24
**Autor**: Claude Code + Team Leader
**Estado**: Ready for implementation
